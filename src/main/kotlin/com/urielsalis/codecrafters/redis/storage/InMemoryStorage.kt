package com.urielsalis.codecrafters.redis.storage

import com.urielsalis.codecrafters.redis.resp.ArrayRespMessage
import com.urielsalis.codecrafters.redis.resp.BulkStringRespMessage
import com.urielsalis.codecrafters.redis.resp.ErrorRespMessage
import com.urielsalis.codecrafters.redis.resp.RespMessage
import com.urielsalis.codecrafters.redis.resp.StreamEntry
import com.urielsalis.codecrafters.redis.resp.StreamEntryId
import com.urielsalis.codecrafters.redis.resp.StreamRespMessage
import java.time.Instant

open class InMemoryStorage : Storage {
    private val map = mutableMapOf<String, Pair<Instant, RespMessage>>()
    override fun set(key: String, value: RespMessage, expiry: Instant) {
        synchronized(map) {
            map[key] = expiry to value
        }
    }

    override fun get(key: String): RespMessage? {
        synchronized(map) {
            val pair = map[key] ?: return null
            if (Instant.now().isAfter(pair.first)) {
                map.remove(key)
                return null
            }
            return pair.second
        }
    }

    override fun getConfig(key: String): ArrayRespMessage? {
        return null
    }

    override fun getKeys(pattern: String): ArrayRespMessage {
        val keys = if (pattern == "*") {
            map.keys
        } else {
            map.keys.filter { it.matches(pattern.toRegex()) }
        }
        return ArrayRespMessage(keys.map { BulkStringRespMessage(it) })
    }

    override fun getType(key: String): String {
        return when (val value = get(key)) {
            is BulkStringRespMessage -> "string"
            is ArrayRespMessage -> "list"
            is StreamRespMessage -> "stream"
            null -> "none"
            else -> throw IllegalArgumentException("Unsupported type " + value::class.simpleName)
        }
    }

    override fun xadd(
        streamKey: String, entryId: String, arguments: Map<String, String>
    ): RespMessage {
        synchronized(map) {
            val entryIdObj = getEntry(streamKey, entryId, arguments)
            if (entryIdObj.first is StreamRespMessage) {
                set(streamKey, entryIdObj.first, Instant.MAX)
                return entryIdObj.second!!.let { BulkStringRespMessage("${it.ms}-${it.seq}") }
            }
            return entryIdObj.first
        }
    }

    private fun getEntry(
        streamKey: String, entryId: String, arguments: Map<String, String>
    ): Pair<RespMessage, StreamEntryId?> {
        // Validate that we have number-number
        if (!entryId.contains("-")) {
            return ErrorRespMessage("Invalid stream ID, fully autogenerated IDs not supported yet") to null
        }
        val entryIdParts = entryId.split("-")
        if (entryIdParts.size != 2) {
            return ErrorRespMessage("Invalid stream ID") to null
        }
        if (entryIdParts[1] == "*") {
            return ErrorRespMessage("Invalid stream ID, partially autogenerated IDs not supported yet") to null
        }
        val (idMs, idSeq) = try {
            entryIdParts[0].toLong() to entryIdParts[1].toLong()
        } catch (e: NumberFormatException) {
            return ErrorRespMessage("Invalid stream ID") to null
        }

        // Validate we are greater than 0-0
        if (idMs < 0 || idSeq < 0) {
            return ErrorRespMessage("ERR The ID specified in XADD must be greater than 0-0") to null
        }
        if (idMs == 0L && idSeq == 0L) {
            return ErrorRespMessage("ERR The ID specified in XADD must be greater than 0-0") to null
        }

        // Validate that we fit!
        val currentStream = get(streamKey)
        if (currentStream != null && currentStream !is StreamRespMessage) {
            return ErrorRespMessage("WRONGTYPE Operation against a key holding the wrong kind of value") to null
        }
        //     No current stream, so we do!
        if (currentStream == null) {
            val id = StreamEntryId(idMs, idSeq)
            return StreamRespMessage(streamKey, mutableListOf(StreamEntry(id, arguments))) to id
        }
        //     Current stream, so we ddo need to check
        val existingStream = currentStream as StreamRespMessage
        val maxMs = existingStream.values.maxOf { it.id.ms }
        val maxSeq = existingStream.values.filter { it.id.ms == maxMs }.maxOf { it.id.seq }
        if (idMs < maxMs) {
            return ErrorRespMessage("ERR The ID specified in XADD is equal or smaller than the target stream top item") to null
        }
        if (idMs == maxMs && idSeq <= maxSeq) {
            return ErrorRespMessage("ERR The ID specified in XADD is equal or smaller than the target stream top item") to null
        }
        // Add it!
        val id = StreamEntryId(idMs, idSeq)
        existingStream.values.add(StreamEntry(id, arguments))
        return existingStream to id
    }

}
